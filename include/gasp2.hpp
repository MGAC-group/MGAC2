#pragma once
#include "gasp2common.hpp"
#include "gasp2param.hpp"
#include "gasp2struct.hpp"
#include "gasp2pop.hpp"
//#include "gasp2qe.hpp"


using namespace std;


/*
 * GASP2 scheduling model
 *
 * 1) Workflow
 * -The server and clients are initialized.
 * -Both server and the clients read the input file.
 * -The server generates a new population from the
 * root structure definition. This becomes the rootpop.
 * -The server fitcells the rootpop, then forks off
 * structures that pass the volume constraints
 * -The forked structures are sent for eval. Size of
 * structure is taken into account by tiling on nodes.
 * -A new set of structures is generated by crossing.
 * -New pop is fitcelled, volume limited, and eval'd.
 * -Elitism filter is applied (or not, depending on mode).
 * -Repeat until limits reached.
 *
 * 2) Send/Receive Instructions
 * Instruction send/receive is handle my the main thread
 * on all clients. Every 15 seconds both clients and server
 * check for incoming messages. If there is an incoming message,
 * it is received and handled.
 *
 * Instructions are bitmasks, so multiple instructions can be sent at once.
 *
 *
 * The priority of execution is as follows:
 * a) Prepare send for pop
 * b) Send pingback with Ack/PopAvail
 * c) DoFitcell
 * d) DoCharmm
 * e) DoQE
 * f) DoCustom
 *
 * So, a bitmask of 11101010 would first fork a thread for the Pop send,
 * send 000010111 (for PopAvail, Acknowledging ping, and Now busy
 *
 *
 * Ping - Immediately returns a Busy/Ready to sender (usually server).
 *
 *
 */

typedef struct Host {
	string hostname;
	int threads;
}Host;

typedef enum Instruction {
	Ack = (1u<<0), //acknowledge
	Ping = (1u<<1), //message sent by server to test readiness
	Busy = (1u<<2), //sent by client when busy with work; a 0 implies Ready
	SendPop = (1u<<3), 	//server order to client to send pop (regardless of eval state)
	PopAvail = (1u<<4), //sent when a population is queued and ready for transmit
	DoFitcell = (1u<<5), //order to client to perform fitcell
	DoCharmm = (1u<<6), //reserved for future usage, not implemented
	DoQE = (1u<<7), //order to client to perform QE
	DoCustom = (1u<<8), //order to client to perform custom eval

}Instruction;

class GASP2control {
public:
	GASP2control(int ID, string infile);
	GASP2control(time_t start, int size, string input, string restart="");
	void server_prog();
	void client_prog();

private:
	//procedural variables
	time_t starttime;
	string infile;
	string restart;
	int worldSize;
	int ID;

	string hostname;
	int nodethreads;

	GASP2param params;
	GASP2struct root; //base structure which all other structures are derived from
	GASP2pop rootpop; //masterstructure list
	vector<GASP2pop> popbuff;

	vector<Host> hostlist;

	//control instructions
	bool sendIns(Instruction i, int target);
	bool recvIns(Instruction i, int target);

	//population send/recv
	bool sendPop(GASP2pop p, int target);
	bool recvPop(GASP2pop &p, int sender);

	//for sending MPI host info between nodes
	bool sendHost(string host, int procs, int target);
	bool recvHost(string &host, int &procs, int target);

	void getHostInfo();

	bool parseInput(tinyxml2::XMLDocument *doc, string & errors);

};
